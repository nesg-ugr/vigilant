# VIGILANT Backend and Platform Architecture

## 1. Overview

VIGILANT is an agentic AI platform for cybersecurity investigations, initially focused on the analysis of network traces from PCAP files. The platform consists of:

- A **FastAPI** backend.
- A **Postgres** database with **pgvector** for embeddings.
- A **PCAP storage and parsing subsystem**, including a sessions index.
- **Agentic workflows** implemented with **LangChain** and **LangGraph**.
- **LLM inference** served via **vLLM**.
- **LLM observability** using **Phoenix** (Arize Phoenix).
- An **MCP server** exposing tools for external LLM agents.
- A **RAG module** for semantic search over past investigation reports.
- A separate **Web UI** (VIGILANT frontend, described in a separate document) that consumes REST endpoints from this backend.

The main product of the system for each PCAP is an **investigation** that includes:

- A Phase 1 technical Q&A transcript (analyst questions, tool results, LLM answers).
- A Phase 2 intelligence report summarizing findings and recommendations.
- A rendered PDF report stored on disk.

---

## 2. Core Concepts

### 2.1 PCAP

A PCAP represents a raw packet capture file:

- Stored on the filesystem.
- Described in the database by `pcap_files` metadata.
- Used as the source of truth for detailed protocol-level data.

### 2.2 Network Sessions

Network sessions (or flows) are aggregated units derived from PCAP packets:

- Grouped by {source IP, source port, destination IP, destination port, protocol}.
- Stored in the `network_sessions` table.
- Used as a fast index for many common queries (e.g., connections to specific ports, top talkers).

Sessions complement, but do not replace, deeper layer analysis tools.

### 2.3 Investigation

An investigation is a single analysis session tied to a specific PCAP:

- Represents both:
  - Phase 1: technical interrogation (Q&A).
  - Phase 2: intelligence report generation.
- Identified by an `investigations` row.

### 2.4 Investigation Messages

The Phase 1 transcript is a sequence of messages:

- Analyst questions.
- Tool outputs (structured JSON).
- Assistant answers from the LLM.

Messages are stored as rows in `investigation_messages` and together form the full investigation transcript.

### 2.5 Investigation Report

The Phase 2 intelligence report is a structured summary:

- Generated by the LLM from the transcript.
- Stored as **text/markdown** in `investigation_reports.summary_text`.
- Associated metadata (severity, protocols, tags) is stored in `investigation_reports.metadata`.
- A **PDF** version is rendered and stored on disk, with path stored in `investigation_reports.pdf_path`.

### 2.6 RAG Over Reports

Relevant chunks of report text (and optionally other textual objects) are embedded and stored in `embeddings` using pgvector. A RAG endpoint allows semantic search over these embeddings to find similar past investigations and support cross-case analysis.

---

## 3. Technology Stack

- **Language**: Python 3.11+
- **Web framework**: FastAPI
- **Database**: PostgreSQL 15+ with `pgvector`
- **ORM & Migrations**: SQLAlchemy + Alembic
- **Agent Framework**: LangChain + LangGraph
- **LLM Serving**: vLLM (HTTP endpoint; model configurable)
- **Embeddings**: LangChain embeddings, stored in pgvector
- **Observability**: Phoenix (Arize Phoenix) integrated with LangChain / LangGraph
- **MCP**: Model Context Protocol server in Python, co-located with FastAPI
- **Containerization**: Docker and Docker Compose
- **Auth**: API key-based authentication for v1

---

## 4. Storage Layout

### 4.1 Filesystem

Two key directories are used for large artifacts:

- PCAP storage:

  - Environment variable: `PCAP_STORAGE_DIR` (default `/data/pcaps`).
  - Files saved as: `${PCAP_STORAGE_DIR}/${pcap_id}.pcap`.

- Report PDF storage:

  - Environment variable: `REPORT_STORAGE_DIR` (default `/data/reports`).
  - Files saved as: `${REPORT_STORAGE_DIR}/${report_id}.pdf`.

In a Docker deployment, these paths are backed by named volumes to ensure persistence.

### 4.2 Database Schema

The database schema is designed around the main concepts: PCAP files, sessions, investigations, messages, reports, embeddings, and API keys.

#### 4.2.1 `pcap_files`

Metadata for each PCAP file.

Fields:

- `id` (UUID, primary key)
- `original_filename` (text, not null)
- `stored_path` (text, not null)  
  Example: `/data/pcaps/<uuid>.pcap`
- `uploaded_at` (timestamptz, default = now)
- `file_size_bytes` (bigint, not null)
- `hash_sha256` (text, unique)
- `status` (enum: `uploaded`, `parsed`, `parse_failed`)
- `notes` (text, nullable)

Indexes:

- Index on `uploaded_at`.
- Index on `status`.

#### 4.2.2 `network_sessions`

Session-level index of traffic derived from a PCAP.

Fields:

- `id` (UUID, primary key)
- `pcap_id` (UUID, FK → `pcap_files.id`, indexed)
- `src_ip` (text or `inet`)
- `src_port` (int, nullable)
- `dst_ip` (text or `inet`)
- `dst_port` (int, nullable)
- `protocol` (text, e.g., `TCP`, `UDP`, `ICMP`)
- `start_time` (timestamptz, nullable)
- `end_time` (timestamptz, nullable)
- `packet_count` (int)
- `byte_count` (bigint)
- `features_json` (JSONB, nullable)  
  Example: `{ "syn_count": 10, "fin_count": 2, "mean_iat_ms": 5.4 }`

Indexes:

- Index on `(pcap_id)`.
- Index on `(pcap_id, src_ip, dst_ip)`.
- Index on `(pcap_id, dst_port)`.

#### 4.2.3 `investigations`

Represents an investigation session tied to a PCAP.

Fields:

- `id` (UUID, primary key)
- `pcap_id` (UUID, FK → `pcap_files.id`, indexed)
- `title` (text)
- `started_at` (timestamptz, default = now)
- `completed_at` (timestamptz, nullable)
- `status` (enum: `active`, `completed`, `failed`, `abandoned`)
- `initiated_by` (text, nullable)
- `parameters` (JSONB, nullable)

#### 4.2.4 `investigation_messages`

Stores the transcript of questions, tool outputs, and answers for an investigation.

Fields:

- `id` (UUID, primary key)
- `investigation_id` (UUID, FK → `investigations.id`, indexed)
- `created_at` (timestamptz, default = now, indexed)
- `role` (enum: `analyst`, `assistant`, `tool`)
- `type` (text, nullable) – e.g., `question`, `answer`, `tool_call`, `tool_result`
- `content` (JSONB, not null)

  Suggested structure of `content`:

  ```json
  {
    "text": "optional text for analyst or assistant",
    "data": {},
    "format": "markdown"  // or "json"
  }
  ```

- `tool_name` (text, nullable) – when `role = 'tool'`
- `metadata` (JSONB, nullable) - for trace info, token usage, etc.

#### 4.2.5 `investigation_reports`

Stores the Phase 2 intelligence report for each investigation.

Fields:

- `id` (UUID, primary key)
- `investigation_id` (UUID, FK → `investigations.id`, unique)
- `created_at` (timestamptz, default = now)
- `title` (text)
- `summary_text` (text) - the full report text in markdown format 
- `pdf_path` (text, nullable) - filesystem path to the rendered PDF
- `metadata` (JSONB, nullable) - for severity, protocols, tags, etc.

  Example `metadata`:

  ```json
  {
    "severity": "critical",
    "protocols": ["RDP", "SSH"],
    "tags": ["brute_force", "lateral_movement"],
    "summary": "Short one-sentence summary."
  }
  ```

#### 4.2.6 `embeddings`

Stores vector embeddings for text chunks used in RAG.

Fields:

- `id` (UUID, primary key)
- `object_type` (enum: e.g., `report_chunk`, `message_chunk`)
- `object_id` (UUID) – ID of a related object (e.g., `investigation_reports.id`)
- `chunk_index` (int) – index of the chunk within the object
- `text` (text, not null) – the textual content of the chunk
- `embedding` (vector, not null) – pgvector column
- `metadata` (JSONB, nullable) – includes `investigation_id`, `pcap_id`, severity, protocol tags, timestamps, etc.

Indexes:

- `ivfflat` index on `embedding` for efficient similarity search.
- B-tree index on `(object_type, object_id)`.


#### 4.2.7 `api_keys`
Stores hashed API keys for backend authentication.

Fields:

- `id` (UUID, primary key)
- `key_hash` (text, unique)
- `label` (text)
- `created_at` (timestamptz, default = now)
- `revoked_at` (timestamptz, nullable)


## 5. PCAP Upload and Session Parsing
### 5.1 PCAP Upload

Endpoint:

- `POST /pcaps/upload` (multipart form-data)

Behavior:
1. The backend accepts a file upload with field name file.
2. It generates a new `pcap_id` (UUID).
3. It writes the file to `${PCAP_STORAGE_DIR}/${pcap_id}.pcap`.
4. It calculates:
- `file_size_bytes`
- `hash_sha256`
5. It creates a `pcap_files` row with:
- `id = pcap_id`
- `original_filename`
- `stored_path`
- `uploaded_at`
- `file_size_bytes`
- `hash_sha256`
- `status = 'uploaded'`
6. It returns a JSON object like:
```json
{
    "pcap_id": "uuid-1",
    "status": "uploaded"
}
```
### 5.2 Session Parsing

After upload, VIGILANT parses the PCAP into sessions to populate `network_sessions`:

Module responsibility:

- `pcaps.parser.parse_pcap(pcap_id: UUID)`

Behavior:
1. Looks up `pcap_files.stored_path` for the given `pcap_id`.
2. Uses a packet parsing library (e.g., scapy, pyshark) to iterate over packets.
3. Groups packets into flows by:
- `src_ip`
- `src_port`
- `dst_ip`
- `dst_port`
- `protocol`
4. For each flow, computes:
- `packet_count`
- `byte_count`
- `start_time`
- `end_time`
- Any additional basic features stored in features_json.

5. Inserts one row per session in `network_sessions`.

6. Updates `pcap_files.status`:
- `parsed` on success.
- `parse_failed` on error.

This sessions table is then available for OSI-layer tools to query and for faster responses to common questions, without re-reading the entire PCAP every time.

## 6. OSI-Layer Tools

VIGILANT uses a set of tools conceptually aligned with OSI layers to answer questions about specific aspects of the network trace. These tools:

- Accept at minimum a `pcap_id`.
- Accept optional filters (such as IPs, ports, time windows).
- Produce structured JSON results.
- Can leverage both `network_sessions` and direct PCAP inspection where appropriate.

These tools are:

- Used internally by LangGraph workflows.
- Exposed via MCP to external LLM agents.
- Optionally exposed as REST endpoints if needed.

### 6.1 Example: Layer 3 (Network) Summary Tool

Function (internal):

- `layer3_summary(pcap_id, filters) -> dict`

Responsibilities:

- Uses `network_sessions` (and/or PCAP) to derive:
  - Total number of unique IP addresses.
  - Sets of public vs private IP addresses.
  - IP version distribution (IPv4 vs IPv6).
  - Other network-layer statistics as needed.

Example output:
```json
{
  "pcap_id": "uuid-1",
  "total_unique_ips": 42,
  "public_ips": ["198.51.100.1"],
  "private_ips": ["10.0.0.1", "192.168.0.5"],
  "ip_version_distribution": { "IPv4": 95, "IPv6": 5 }
}
```

### 6.2 Example: Layer 4 (Transport) Summary Tool

Function (internal):

- `layer4_summary(pcap_id, filters) -> dict`

Responsibilities:

- Uses `network_sessions` to provide:
  - Total number of sessions.
  - Number of sessions to each destination port.
  - Top ports by session count or bytes.
  - Basic statistics on TCP flags or connection behavior.

Example output:
```json
{
  "pcap_id": "uuid-1",
  "total_sessions": 3000,
  "sessions_to_port": {
    "22": 120,
    "443": 450,
    "3389": 15
  },
  "top_ports_by_bytes": [
    { "port": 443, "byte_count": 1234567 },
    { "port": 22, "byte_count": 543210 }
  ]
}
```

### 6.3 Example: Layer 7 (Application) Summary Tool

Functions (internal):

- `layer7_http_summary(pcap_id, filters) -> dict`
- `layer7_dns_summary(pcap_id, filters) -> dict`
- `layer7_tls_summary(pcap_id, filters) -> dict`
- Others as needed.

Responsibilities:

-   Extract protocol-specific information by inspecting relevant traffic:
    - HTTP: hosts, URLs, user agents, status codes.
    - DNS: queries, responses, record types.
    - TLS: SNI, versions, cipher suites.

Example HTTP summary output:
```json
{
  "pcap_id": "uuid-1",
  "total_http_requests": 500,
  "unique_hosts": ["example.com", "api.example.com"],
  "top_user_agents": [
    { "user_agent": "curl/7.68.0", "count": 200 },
    { "user_agent": "Mozilla/5.0 ...", "count": 150 }
  ]
}
```

All of these tools can be called by the investigation Q&A workflow and by MCP tools, providing a rich set of capabilities for analysts and agents.

## 7. Agentic Workflows with LangGraph

VIGILANT uses LangGraph to orchestrate multi-step workflows.

### Phase 1 - Investigation Q&A Workflow

Graph name: `investigation_qa_graph`.

Input:
- `investigation_id` (UUID)
- `question_text` (string)

High-level flow:
1. StoreAnalystMessageNode:
  - Creates a new `investigation_messages` row:
    - `role="analyst"`
    - `content.text = question_text`

2. ToolSelectionNode:
  - Uses a small LLM or heuristics to decide:
    - Which OSI-layer tools to call (e.g., layer3_summary, layer4_summary, layer7_http_summary, etc.).
    - What filters should be applied (ports, IPs, etc.) based on the question.

  - Produces a plan (e.g., a list of (tool_name, tool_args)).

3. ToolExecutionNode:
  - Executes each planned tool call.
  - For each tool result:
    - Stores a `investigation_messages` row with:
      - `role="tool"`
      - `tool_name`
      - `content.data = <result JSON>`
      - `content.format = "json"`

4. AnswerGenerationNode:
- Constructs a prompt for the LLM that includes:
  - The analyst’s question.
  - A concise textual representation of the tool outputs.
- Calls the vLLM-backed model via LangChain.
- Receives an answer in text/markdown.
- Stores a `investigation_messages` row with:
  - `role="assistant"`
  - `content.text = <answer>`
  - `content.format = "markdown"`

5. ReturnNewMessagesNode:
  - Returns the set of new messages generated during this workflow run for API consumption.

Throughout the workflow, Phoenix tracing is used to capture LLM calls and tool interactions.

### 7.2 Phase 2 - Investigation Report Workflow

Graph name: `investigation_report_graph`.

Input:
- `investigation_id` (UUID)

High-level flow:
1. LoadTranscriptNode:
  - Fetches all `investigation_messages` associated with the investigation.
  - Optionally orders and formats them into a transcript for the report.

2. ReportDraftNode:
  - Calls the LLM with:
    - Context about the environment and PCAP.
    - The full transcript.
  - Instructs the LLM to produce an intelligence report with sections such as:
    - Executive summary.
    - Key findings & evidence.
    - Impact assessment.
    - Recommended actions.
    - Limitations / uncertainties.
  - Output is markdown text.

3. MetadataExtractionNode:
  - Calls the LLM again with the report draft to extract structured metadata:
    - `severity` (e.g., `low`, `medium`, `high`, `critical`).
    - `protocols` (list of strings).
    - `tags` (list of strings describing the investigation).
    - A short `summary` string.
  - Stores this as JSON.

4. PersistReportNode:
  - Creates an `investigation_reports` row:
    - `summary_text` = report markdown.
    - `metadata` = extracted JSON.
    - `title` = from either a prompt or extracted from the markdown.

5. PdfRenderNode:
  - Renders the markdown to HTML and then to a PDF.
  - Saves the PDF file to `${REPORT_STORAGE_DIR}/${report_id}.pdf`.
  - Updates `investigation_reports.pdf_path` with this path.

6. EmbeddingNode:
  - Splits `summary_text` into chunks (e.g., 500–1000 tokens).
  - Uses an embedding model to create embeddings for each chunk.
  - Inserts rows into `embeddings` with:
    - `object_type = "report_chunk"`
    - `object_id = report_id`
    - `chunk_index`
    - `text` (chunk content)
    - `embedding`
    - `metadata` (including `investigation_id`, `pcap_id`, severity, protocols, timestamps).

## 8. LLM and Embeddings Integration

### 8.1 vLLM Integration

A LangChain `ChatModel` wrapper is configured for vLLM.

- Environment variables:
  - `VLLM_ENDPOINT_URL`
  - `VLLM_MODEL_NAME`
- The wrapper:
  - Sends chat/completion requests to vLLM’s HTTP API.
  - Handles timeouts and retries.
  - Is used in both Q&A and report-generation workflows.

### 8.2 Embeddings

An embedding model is used with LangChain:

- Environment variable:
  - `EMBEDDING_MODEL_NAME`
- Responsible for:
  - Embedding report chunks for RAG.
  - Embedding query text for RAG.

Embeddings are stored in the `embeddings` table with pgvector.

## 9. RAG Module for Reports
### 9.1 Embedding Generation

As part of report creation:

1. `summary_text` is chunked into textual segments.
2. Each segment is embedded.
3. Each embedding is stored in embeddings with:
  - `object_type = "report_chunk"`
  - `object_id = report_id`
  - `text` = the chunk’s text
  - `embedding` vector
  - `metadata` including:
    - `investigation_id`
    - `pcap_id`
    - `severity`
    - `protocols`
    - Time information.

### 9.2 RAG Query Endpoint

Endpoint:

- `POST /rag/reports/query`

Request structure:
```json
{
  "query": "<free-text query>",
  "top_k": 10,
  "filters": {
    "severity": "critical",
    "protocol": "RDP",
    "from": "2025-10-01T00:00:00Z",
    "to": "2025-11-01T00:00:00Z"
  }
}
```
Processing steps:
1. The query text is embedded using the embedding model.
2. A pgvector similarity search is run against `embeddings` where:
  - `object_type = 'report_chunk'`
  - Additional filters (severity, protocol, date range) are applied based on `metadata`.
3. Results are sorted by similarity (e.g., cosine distance).
4. The top `top_k` results are selected.
5. Results are grouped by `report_id` (`object_id`), and the corresponding `investigation_reports` and `investigations` are looked up.
6. Optionally, a summarization LLM call produces an `answer` string summarizing the matches.

Example response:
```json
{
  "answer": "There are several previous investigations involving RDP brute force...",
  "matches": [
    {
      "report_id": "rep-999",
      "investigation_id": "inv-1",
      "title": "SSH brute force in DMZ",
      "snippet": "In this investigation, repeated failed SSH attempts...",
      "score": 0.12,
      "metadata": {
        "severity": "critical",
        "protocols": ["SSH"],
        "tags": ["brute_force"]
      }
    }
  ]
}
```
## 10. REST API Surface

The REST API provides endpoints for PCAPs, investigations, messages, reports, and RAG. These endpoints are consumed by the VIGILANT Web UI and can also be used by other clients.

### 10.1 Health

- `GET /health`
  - Response: JSON with at least `status` (e.g., `{ "status": "ok", "version": "..." }`).

### 10.2 PCAPs

- `GET /pcaps`
  - Optional query parameters for paging and filters.
  - Returns an array of PCAP summaries.

- `GET /pcaps/{pcap_id}`
  - Returns details for a single PCAP.

- `POST /pcaps/upload`
  - Accepts `multipart/form-data` with `file`.
  - Saves file and returns `pcap_id` and `status`.

### 10.3 Investigations

- `GET /investigations`
  - Query parameters can include:
    - `pcap_id`
    - `status`
    - `severity` (via report metadata)
    - `protocol`
    - `from`, `to` (date range)
  - Returns a list of investigations with embedded report + PCAP metadata.

- `POST /pcaps/{pcap_id}/investigations`
  - Optional JSON body with `title`.
  - Creates an investigation and returns its `investigation_id` and status.

- `GET /investigations/{id}`
  - Returns an investigation’s details (not including messages).

### 10.4 Messages

- `GET /investigations/{id}/messages`
  - Returns an array of `investigation_messages` sorted by `created_at`.

- `POST /investigations/{id}/messages`
  - Expected body:
  ```json
  {
    "role": "analyst",
    "content": {
      "text": "<question text>"
    }
  }
  ```
  - Invokes the Phase 1 Q&A workflow.
  - Returns:
  ```json
  {
    "new_messages": [ ...message objects... ]
  }
  ```

### 10.5 Reports

- `POST /investigations/{id}/generate_report`
  - Triggers the Phase 2 report workflow for an investigation.
  - Returns report metadata when complete.

- `GET /investigations/{id}/report`
  - Returns report details including:
    - `report_id`
    - `title`
    - `created_at`
    - `summary_text`
    - `metadata`
    - `pdf_available` flag.

- `GET /investigations/{id}/report.pdf`
  - Streams the PDF file located at `pdf_path`.

### 10.6 RAG

- `POST /rag/reports/query`
  - Provides RAG-based semantic search over reports.
  - Returns an `answer` plus `matches` as described above.

## 11. MCP Server

The MCP server exposes VIGILANT capabilities as tools for external LLM agents. It runs within the same process as the FastAPI application and uses the same internal service layer.

### 11.1 Core MCP Tools

Possible MCP tools include:

1. `list_pcaps`
  - Input: optional date range or status filters.
  - Output: PCAP summaries similar to `GET /pcaps`.

2. `start_investigation`
  - Input: `pcap_id`, optional `title`.
  - Effect: creates an investigation.
  - Output: `investigation_id`.

3. `send_investigation_question`
  - Input: `investigation_id`, `question_text`.
  - Effect: runs the Phase 1 Q&A workflow.
  - Output: new messages (tool outputs + assistant answer).

4. `generate_investigation_report`
  - Input: `investigation_id`.
  - Effect: runs the Phase 2 workflow.
  - Output: report metadata.

5. `get_investigation_report_text`
  - Input: `investigation_id`.
  - Output: `summary_text` and metadata.

6. `rag_search_reports`
  - Input: `query`, `top_k`.
  - Output: RAG search results as matches with report IDs and investigation IDs.

7. OSI-Layer Tools (for more direct usage by agents):
  - `layer3_summary`
    - Input: `pcap_id`, `filters`.
    - Output: OSI layer 3 summary.
  - `layer4_summary`
    - Input: `pcap_id`, `filters`.
    - Output: OSI layer 4 summary.
  - `layer7_http_summary`
    - Input: `pcap_id`, `filters`.
    - Output: OSI layer 7 HTTP summary.
  - etc.

All tools interact with the same internal modules as used by the REST API.

## 12. Authentication and Security
### 12.1 API Keys

API key authentication is used for REST endpoints:

- Clients send `Authorization: Bearer <API_KEY>` in the header.
- A FastAPI dependency:
  - Extracts the key,
  - Hashes it with `API_KEY_SALT`,
  - Compares against `api_keys.key_hash`.
- Requests with missing/invalid keys result in `401 Unauthorized`.

### 12.2 MCP Security

MCP access can be restricted by network placement or a separate authentication method. For an initial deployment, MCP may be considered internal and restricted to internal networks.

## 13. Configuration

VIGILANT configuration is controlled by environment variables. Key variables include:

- `DATABASE_URL`
- `PCAP_STORAGE_DIR` (default `/data/pcaps`)
- `REPORT_STORAGE_DIR` (default `/data/reports`)
- `VLLM_ENDPOINT_URL`
- `VLLM_MODEL_NAME`
- `EMBEDDING_MODEL_NAME`
- `PGVECTOR_DIM`
- `PHOENIX_ENDPOINT_URL`
- `API_KEY_SALT`
- `DEFAULT_API_KEY` (optional, for development)
- `ENVIRONMENT` (`dev` or `prod`)

A `.env.example` file documents these variables.

## 14. Docker and Docker Compose

The VIGILANT backend is deployed via Docker Compose.

### 14.1 Services

- `api`:
  - Builds from `docker/Dockerfile.api`.
  - Depends on `db`, `vllm`, `phoenix`.
  - Mounts:
    - `pcap_data:/data/pcaps`
    - `report_data:/data/reports`
  - Exposes the FastAPI application port (e.g., `8000`).
- `db` (Postgres):
  - Image: `postgres:15`.
  - Environment includes:
    - `POSTGRES_DB`
    - `POSTGRES_USER`
    - `POSTGRES_PASSWORD`
  - Volume: `db_data:/var/lib/postgresql/data`.
  - Initialization scripts enable the pgvector extension.
- `vllm`:
  - Runs vLLM with a specified model.
  - Exposes HTTP endpoint for LLM calls.
- `phoenix`:
  - Runs the Phoenix observability service.
  - Exposes a web UI port.

### 14.2 Volumes

- `pcap_data` – PCAP storage.
- `report_data` – Report PDF storage.
- `db_data` – Postgres data.

### 14.3 Startup

The system is started with:

```bash
docker compose up --build
```

After startup:

- Backend API is available at e.g. `http://localhost:8000`.
- Phoenix and vLLM are available on their respective ports.

## 15. Code Structure

Suggested backend project layout:
```text
backend/
  app/
    __init__.py
    main.py                     # FastAPI app, MCP integration
    config.py                   # settings via environment variables
    api/
      __init__.py
      routes_health.py
      routes_pcaps.py
      routes_investigations.py
      routes_messages.py
      routes_reports.py
      routes_rag.py
    auth/
      __init__.py
      dependencies.py           # API key auth dependencies
    db/
      __init__.py
      models.py                 # SQLAlchemy models
      session.py                # DB session management
      migrations/               # Alembic migrations
    pcaps/
      __init__.py
      parser.py                 # PCAP → network_sessions parsing
      osi_tools.py              # OSI-layer tools (layer3, layer4, layer7, etc.)
    workflows/
      __init__.py
      investigation_qa_graph.py
      investigation_report_graph.py
      llm_client.py             # vLLM integration
      embeddings.py             # embedding utilities
    mcp/
      __init__.py
      server.py                 # MCP server implementation
      tools.py                  # MCP tools mapping to internal functions
    observability/
      __init__.py
      phoenix_integration.py    # Phoenix tracing config
  tests/
    test_pcaps.py
    test_investigations.py
    test_workflows.py
  docker/
    Dockerfile.api
    docker-compose.yml
  pyproject.toml (or requirements.txt + setup.cfg)
  .env.example
  README.md
```

## 16. Testing

Testing considerations for the VIGILANT backend:

- Unit tests:
  - PCAP parsing and session extraction with sample PCAP files.
  - OSI-layer tools, using small synthetic payloads.
  - Database models and migrations.

- Integration tests:
  - End-to-end flow:
    - Upload PCAP → parse → create investigation → send question → receive tool outputs and LLM answer → generate report → retrieve report and PDF.
  - RAG query behavior with a small set of reports and embeddings.

- Optional checks:
  - Type checking with `mypy`.
  - Static analysis and linting with tools like `ruff` or `flake8`.

VIGILANT’s backend, as described here, provides the foundation for the Web UI and any external LLM agents (via MCP) to perform deep, multi-step, PCAP-based cybersecurity investigations with full audit trail, intelligence reporting, and semantic retrieval over historical cases.